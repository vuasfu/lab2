# lab2
# ФИО: Булгакова Юлия Олеговна

Выполнить все задания в одном проекте в виде отдельных функций. Для всех вводов организовать проверку на корректность данных.

# Постановка задач

# Задание 1
Дан вектор V. Создать новый вектор, который содержит сначала все элементы второй половины вектора V, а затем все элементы первой половины вектора V. Для вывода элементов использовать итератор (для вывода элементов в обратном порядке использовать обратные итераторы, возвращаемые функциями-членами rbegin и rend).

Алгоритм:

1) Определить середину вектора
2) Создать новый вектор
3) Скопировать вторую половину исходного вектора
4) Скопировать первую половину исходного вектора
5) Вывести результат с использованием обратных итераторов

# Реализация:

```cpp
void DelVector(const std::vector<int>& V) {
  std::vector<int> result;

  auto mid = V.begin() + V.size() / 2;

  for (auto it = mid; it != V.end(); ++it){
        result.push_back(*it);
  }
  for (auto it = V.begin(); it != mid; ++it){
        result.push_back(*it);
  }
  
  // Вывод результата через обратные итераторы
  std::cout << "Результат: ";
  for (auto rit = result.rbegin(); rit != result.rend(); ++rit) {
    std::cout << *rit << " ";
  }
  std::cout << "\n";
}
```

# Тестирование
<img width="454" height="198" alt="image" src="https://github.com/user-attachments/assets/06254e53-d5c9-4d9b-829b-40cdf9c1b694" />

# Задание 2
Дан вектор V и список L. Переставить в векторе V элементы в обратном порядке, а затем вставить последние 5 элементов развернутого вектора V после 5-го элемента списка L (предполагается, что элементов в векторе V и списке L достаточно). Использовать алгоритм copy с итераторами вставки.

Алгоритм:

1) Создать временный вектор с элементами в обратном порядке
2) Получить итератор на 5-й элемент списка L
3) Вставить последние 5 элементов развернутого вектора

# Реализация:

```cpp
void razvorot(std::vector<int>& V, std::list<int>& L) {
  // Создаем временный вектор, чтобы развернуть его  
  std::vector<int> demo_vector(V.rbegin(), V.rend()); 
  
  // Берём первые 5 элементов
  auto start = demo_vector.rbegin();
  auto end = demo_vector.rbegin() + 5;

  auto fifth_element = L.begin();
  std::advance(fifth_element, 5);
  L.insert(fifth_element, start, end);
}
```
# Тестирование
<img width="396" height="62" alt="image" src="https://github.com/user-attachments/assets/1688fc51-063a-45b5-9b35-2267f0a65695" />


# Задание 3
Даны списки L1 и L2, имеющие четное количество элементов. Поменять местами первую половину исходного списка L1 и вторую половину исходного списка L2. Использовать два вызова функции-члена splice. Для заполнения контейнера использовать итератор и конструктор соответствующего контейнера, для вывода элементов использовать итератор (для вывода элементов в обратном порядке использовать обратные итераторы, возвращаемые функциями-членами rbegin и rend).

Алгоритм:

1) Определить середины обоих списков
2) Сохранить первую половину L1 во временном списке
3) Переместить вторую половину L2 в начало L1
4) Переместить первую половину L1 в L2
5) Вывести результат с помощью обратных итераторов

Реализация:

```cpp
void peremeshenie(std::list<int>& L1, std::list<int>& L2) {
    // Создаем копии
    std::list<int> copy1 = L1;
    std::list<int> copy2 = L2;
    
    // Очищаем оригиналы
    L1.clear();
    L2.clear();
    
    // Вставляем вторую половину L2 в L1
    auto it = copy2.begin();
    std::advance(it, copy2.size() / 2);
    for (; it != copy2.end(); ++it) {
        L1.push_back(*it);
    }
    
    // Вставляем вторую половину исходного L1 в L1
    it = copy1.begin();
    std::advance(it, copy1.size() / 2);
    for (; it != copy1.end(); ++it) {
        L1.push_back(*it);
    }
    
    // Вставляем первую половину L2 в L2
    it = copy2.begin();
    for (size_t i = 0; i < copy2.size() / 2; ++i) {
        L2.push_back(*it);
        ++it;
    }
    
    // Вставляем первую половину L1 в L2
    it = copy1.begin();
    for (size_t i = 0; i < copy1.size() / 2; ++i) {
        L2.push_back(*it);
        ++it;
    }
    
    // Вывод с использованием обратных итераторов
    std::cout << "\nПосле обмена (обратный порядок):\n";
    std::cout << "L1: ";
    for (auto rit = L1.rbegin(); rit != L1.rend(); ++rit) {
        std::cout << *rit << " ";
    }
    std::cout << "\nL2: ";
    for (auto rit = L2.rbegin(); rit != L2.rend(); ++rit) {
        std::cout << *rit << " ";
    }
    std::cout << "\n";
}
```

# Тестирование
<img width="359" height="384" alt="image" src="https://github.com/user-attachments/assets/376e03c4-329a-4855-a467-a63656baad35" />


# Задание 4
Дан файл текстовый файл, содержащий слова (последовательности символов, разделенные пробелами). Создать новый файл, содержащий только те слова исходного файла, длина которых не превосходит заданного числа K. Использовать итераторы потоков ввода-вывода и алгоритм remove_copy_if.

Алгоритм:

1) Открыть исходный файл для чтения
2) Открыть выходной файл для записи
3) Использовать итераторы потоков для чтения и записи
4) Применить алгоритм remove_copy_if с лямбда-функцией

# Реализация:

``` cpp
void FilterWords(int K, const std::string& name1, const std::string& name2) {
  std::ifstream fin(name1);
  std::ofstream fout(name2);
  
  if (!fin || !fout) return;
  
  // Использовать итераторы для чтения и записи
  std::istream_iterator<std::string> in(fin);
  std::istream_iterator<std::string> end;
  
  std::ostream_iterator<std::string> out(fout, " ");
  
  // remove_copy_if: копируем слова, длина которых <= K
  std::remove_copy_if(in, end, out, [K](const std::string& word){ 
    return word.length() > K; 
  });
}
```
Тестирование
<img width="428" height="274" alt="image" src="https://github.com/user-attachments/assets/17406448-79f1-4d33-9553-b94e7cf14063" />


# Задание 5
Дан дек D, содержащий целые числа (включая нули). Удалить последний элемент дека, равный нулю (если такой элемент есть). Использовать алгоритм find с обратными итераторами для поиска и функцию-член erase для удаления.

Алгоритм:

1) Использовать обратные итераторы для поиска последнего нуля
2) Найти последний ноль с помощью алгоритма find
3) Если ноль найден, удалить его с помощью erase

# Реализация:

``` cpp
void RemoveLastZero(std::deque<int>& D) {
    // ищем последний ноль с конца
    auto r = std::find(D.rbegin(), D.rend(), 0);

    // если нашли ноль
    if (r != D.rend()) {
        // erase принимает обычный итератор
        D.erase((r + 1).base());
    }
}
```
# Тестирование
<img width="388" height="215" alt="image" src="https://github.com/user-attachments/assets/678a5a62-6c74-4929-b45e-26703f2053cb" />
<img width="376" height="214" alt="image" src="https://github.com/user-attachments/assets/0a1793d9-deb9-401f-b8ae-17ae4c289472" />

# Задание 6
Даны числа A и B и векторы V1 и V2. Добавить в начало каждого вектора 5 элементов со значениями A, а в конец — 5 элементов со значениями B. При преобразовании вектора V1 использовать два вызова алгоритма fill_n с функциями inserter и back_inserter, при преобразовании вектора V2 использовать два вызова функции-члена insert.

Алгоритм:

1) Для V1: использовать fill_n с inserter для начала и back_inserter для конца
2) Для V2: использовать insert для начала и конца

# Реализация:

```cpp
void AddElements(int A, int B, std::vector<int>& V1, std::vector<int>& V2) {
    std::fill_n(std::inserter(V1, V1.begin()), 5, A);
    std::fill_n(std::back_inserter(V1), 5, B);
    
    V2.insert(V2.begin(), 5, A);
    V2.insert(V2.end(), 5, B);
}
```
# Тестирование
<img width="451" height="137" alt="image" src="https://github.com/user-attachments/assets/6106a5dc-cf98-43f0-a4c8-9128a59081c8" />

# Задание 7
Дан вектор V с четным количеством элементов. Известно, что первая половина вектора уже отсортирована по возрастанию. Отсортировать все элементы вектора по возрастанию, выполнив вначале сортировку его второй половины алгоритмом sort, а затем слияние обеих половин алгоритмом inplace_merge. Выводить новое содержимое вектора V после применения каждого алгоритма.

Алгоритм:

1) Проверить, что первая половина отсортирована
2) Отсортировать вторую половину с помощью sort
3) Объединить обе половины с помощью inplace_merge
4) Вывести результат после каждого шага

Реализация:

``` cpp
void sort_vector(std::vector<int>& v) {
  if (v.empty()) {
    return;
  }
  
  // Проверяем, что количество элементов четное
  if (v.size() % 2 != 0) {
    std::cerr << "Ошибка: количество элементов должно быть четным" << std::endl;
    return;
  }
  
  size_t half = v.size() / 2;
  
  // Проверяем, что первая половина отсортирована
  for (size_t i = 1; i < half; ++i) {
    if (v[i] < v[i - 1]) {
      std::cerr << "Предупреждение: первая половина вектора не отсортирована по возрастанию" << std::endl;
      break;
    }
  }
  
  std::cout << "Исходный вектор: ";
  print_vector(v);
  
  // Сортируем вторую половину вектора
  std::sort(v.begin() + half, v.end());
  
  std::cout << "После sort второй половины: ";
  print_vector(v);
  
  // Объединяем обе половины
  std::inplace_merge(v.begin(), v.begin() + half, v.end());
  
  std::cout << "После inplace_merge: ";
  print_vector(v);
}
```
# Тестирование
<img width="573" height="217" alt="image" src="https://github.com/user-attachments/assets/ccc5f1dc-9954-47e1-83d5-dbf66562bc6e" />

# Задание 8
Дан список L. Получить вектор V вещественных чисел, содержащий значения среднего арифметического для всех пар соседних элементов исходного списка (количество элементов вектора V должно быть на 1 меньше количества элементов списка L). Использовать алгоритм adjacent_difference с итератором вставки и функциональным объектом, а также функцию-член erase для вектора V.

Алгоритм:

1) Создать пустой вектор V
2) Использовать adjacent_difference с back_inserter и лямбда-функцией
3) Удалить первый элемент вектора (копия первого элемента списка)
4) Вернуть вектор средних значений

Реализация:

```cpp
std::vector<double> list_to_average_vector(const std::list<int>& L) {
    std::vector<double> V;
    
    if (L.size() < 2) {
        return V;
    }
    
    std::adjacent_difference(
        L.begin(), 
        L.end(), 
        std::back_inserter(V), 
        [](int a, int b) { 
            return (static_cast<double>(a) + b) / 2.0; 
        }
    );
    
    V.erase(V.begin());
    
    return V;
}
```
# Тестирование
<img width="356" height="112" alt="image" src="https://github.com/user-attachments/assets/80b16656-34eb-4596-ba3c-61b3ca9741f5" />
<img width="353" height="134" alt="image" src="https://github.com/user-attachments/assets/53ad4f7d-1e79-4782-820b-1503ee50a1e3" />

# Задание 9
Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0 не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N, в которых содержатся все элементы вектора V0 (без учета их повторений). Использовать алгоритм includes, применяя его в цикле к двум множествам, одно из которых создано на основе вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI.

Алгоритм:

1) Создать множество из элементов V0 (удалить дубликаты)
2) Для каждого вектора VI создать множество из его элементов
3) Использовать алгоритм includes для проверки включения
4) Подсчитать количество векторов, содержащих все элементы V0

Реализация:

```cpp
int count_vectors_containing_all(const std::vector<int>& V0, 
                                 const std::vector<std::vector<int>>& vectors) {
    int count = 0;
    
    if (V0.empty()) {
        return 0;
    }
    
    // Создаем множество из элементов V0 (удаляем дубликаты)
    std::set<int> setV0(V0.begin(), V0.end());
    
    // Проверяем каждый вектор из набора
    for (const auto& vec : vectors) {
        // Создаем множество из элементов текущего вектора
        std::set<int> currentSet(vec.begin(), vec.end());
        
        // Проверяем, содержит ли currentSet все элементы из setV0
        bool containsAll = std::includes(
            currentSet.begin(), currentSet.end(),
            setV0.begin(), setV0.end()
        );
        
        if (containsAll) {
            ++count;
        }
    }
    
    return count;
}
```
# Тестирование
<img width="498" height="416" alt="image" src="https://github.com/user-attachments/assets/d88d5523-33c8-419c-b18a-4bae1e46efd9" />

# Задание 10
Дан вектор V, элементами которого являются английские слова, набранные заглавными буквами. Определить суммарную длину слов, начинающихся с одной и той же буквы, и вывести все различные буквы, с которых начинаются элементы вектора V, вместе с суммарной длиной этих элементов (в алфавитном порядке букв); длину выводить сразу после соответствующей буквы. Использовать вспомогательное отображение M, ключами которого являются начальные буквы элементов вектора V, а значениями — суммарная длина этих элементов. При заполнении отображения M не использовать условные конструкции (достаточно операций индексирования [], инкремента и функции-члена size для строк). Элементы вектора V (при заполнении отображения M) и элементы отображения M (при выводе полученных результатов) перебирать в цикле с параметром-итератором соответствующего контейнера.

Алгоритм:

1) Создать отображение map<char, int>
2) Для каждого слова добавить его длину к соответствующей букве
3) Вывести результат в алфавитном порядке

Реализация:

```cpp
void process_words(const std::vector<std::string>& V) {
    // Вспомогательное отображение: ключ - первая буква, значение - суммарная длина
    std::map<char, int> M;
    
    // Заполняем отображение M
    // Используем итератор для перебора вектора V
    for (auto it = V.begin(); it != V.end(); ++it) {
        const std::string& word = *it;
        
        if (!word.empty()) {
            char first_letter = word[0];
            // Используем операцию индексирования []
            // Если ключа нет, он создается с нулевым значением
            M[first_letter] += word.size(); // Инкрементируем суммарную длину
        }
    }
    
    // Выводим результаты
    // Используем итератор для перебора отображения M
    for (auto it = M.begin(); it != M.end(); ++it) {
        std::cout << it->first << " " << it->second << std::endl;
    }
}
```
# Тестирование
<img width="495" height="268" alt="image" src="https://github.com/user-attachments/assets/34b78773-1e3c-4284-8654-29f78adcaad5" />

